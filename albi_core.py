"""Albi Core â€“ adaptive learning and analytics layer.

This module consumes frames produced by ALBA and derives knowledge artefacts
that can be stored or queried by other services. The implementation relies on
pure Python to keep the dependency surface minimal while still yielding useful
aggregations.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Any, Optional, Iterable

import json
import statistics
import time


@dataclass
class Insight:
	"""Knowledge artefact generated by ALBI."""

	timestamp: float
	summary: Dict[str, float]
	anomalies: List[str] = field(default_factory=list)
	source_frame_count: int = 0


class AlbiCore:
	"""Learning engine that turns signal frames into insights."""

	def __init__(self, *, anomaly_threshold: float = 0.25) -> None:
		self.anomaly_threshold = anomaly_threshold
		self._insights: List[Insight] = []
		self._status = "idle"
		self._started_at: Optional[float] = None

	# --------------------------------------------------------------
	# lifecycle
	# --------------------------------------------------------------
	def start(self) -> None:
		if self._status == "running":
			return
		self._status = "running"
		self._started_at = time.time()

	def stop(self) -> None:
		if self._status == "idle":
			return
		self._status = "idle"
		self._started_at = None

	# --------------------------------------------------------------
	# learning
	# --------------------------------------------------------------
	def learn(self, frames: Iterable[Dict[str, Any]]) -> Insight:
		if self._status != "running":
			self.start()

		channels: Dict[str, List[float]] = {}
		count = 0
		for entry in frames:
			data = entry.get("channels") or {}
			for name, value in data.items():
				channels.setdefault(name, []).append(float(value))
			count += 1

		summary = {k: statistics.fmean(v) for k, v in channels.items()} if channels else {}
		anomalies = self._detect_anomalies(summary)
		insight = Insight(timestamp=time.time(), summary=summary, anomalies=anomalies, source_frame_count=count)
		self._insights.append(insight)
		return insight

	def learn_from_alba(self, alba_history: Iterable[Any]) -> Insight:
		frames = [{"channels": frame.channels} for frame in alba_history]
		return self.learn(frames)

	def _detect_anomalies(self, summary: Dict[str, float]) -> List[str]:
		if not summary:
			return []
		avg = statistics.fmean(summary.values())
		anomalies: List[str] = []
		for channel, value in summary.items():
			deviation = abs(value - avg)
			if avg and deviation / abs(avg) > self.anomaly_threshold:
				anomalies.append(channel)
		return anomalies

	# --------------------------------------------------------------
	# querying and persistence
	# --------------------------------------------------------------
	def insights(self) -> List[Insight]:
		return list(self._insights)

	def latest(self) -> Optional[Insight]:
		return self._insights[-1] if self._insights else None

	def recommendations(self) -> Dict[str, Any]:
		latest = self.latest()
		if not latest:
			return {"status": "no-data"}
		return {
			"status": "ok" if not latest.anomalies else "attention",
			"focus_channels": latest.anomalies,
			"avg_levels": latest.summary,
		}

	def export(self, target: Path | str) -> Path:
		data = [
			{
				"timestamp": insight.timestamp,
				"summary": insight.summary,
				"anomalies": insight.anomalies,
				"source_frame_count": insight.source_frame_count,
			}
			for insight in self._insights
		]
		path = Path(target)
		path.write_text(json.dumps(data, indent=2), encoding="utf-8")
		return path

	def load(self, source: Path | str) -> int:
		path = Path(source)
		if not path.exists():
			return 0
		payload = json.loads(path.read_text(encoding="utf-8-sig"))
		self._insights.clear()
		for entry in payload:
			insight = Insight(
				timestamp=entry["timestamp"],
				summary=entry.get("summary", {}),
				anomalies=entry.get("anomalies", []),
				source_frame_count=entry.get("source_frame_count", 0),
			)
			self._insights.append(insight)
		return len(self._insights)

	def health(self) -> Dict[str, Any]:
		uptime = 0.0
		if self._status == "running" and self._started_at:
			uptime = time.time() - self._started_at
		return {
			"module": "ALBI",
			"status": self._status,
			"uptime_seconds": uptime,
			"insight_count": len(self._insights),
			"latest": self.latest().summary if self.latest() else {},
		}


__all__ = ["Insight", "AlbiCore"]

